[DOC]

# 多线程一定是处理IO的最优解吗？
由于线程的创建和切换，需要下沉到内核态，调用底层的API才能完成，用户态与内核态的不断转换是耗时的



协程，是一种用户态的线程，每个协程都有自己的一个执行栈，切换都是在用户态进行处理。



协程出来较早，但并不出名，直到高并发问题越来越严重，用户态和内核态都吃不消大量的线程，内存告急，协程最出名的还属和IO多路复用结合，是一个高并发的解决方案。



与其让操作系统调度，不如我自己来，这就是协程。



**PS**:Android中kotlin的协程，严格意义上说，并不属于协程，只能说是一个JAVA中多线程的API封装，并且让开发者更方便地去处理多线程以及线程的切换。

# 如何保证线程的处理是安全的？

使用锁以及原子性、可见性、有序性

# 可见性
> 一个线程对共享变量值得修改，能够及时地被其他线程看到.
可见性的两种方式，**`syschronized`** 和 **`volatile`**
## syschronized
在JAVA内存模型中有对 syschronized 的两条规定：
>1.必须把共享变量的最新值更新到主内存中<br>
>2.线程加锁时，将清空工作内存中的共享变量的值，从而在使用共享变量时就必须要从主内存重新读取最新的值

因此，这样就可以保证了可见性

# 原子性
即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>
比如 num++，它在程序执行的时候是分成三步：
>1.读取num的值<br>
>2.将num的值 +1<br>
>3.写入最新的num值<br>

所以使用 **volatile** 只能保证变量在读或者写的当前阶段，保证可见性，<br>
假设一个线程执行到上述的1操作，第二个线程执行到2操作，那么就会造成结果不正确。
## volatile的使用场合

>对变量的写入操作不依赖其当前值，比如 num++，num=num+1 等
>该变量没有包含在具体的其他变量中的不变式中，比如有两个被volatile修饰的变量，A和B，那么  A<B 这样的操作，就不能使用 volatile

因此 volatile的使用场合和 syschronized相较而言会比较少，但是 volatile不需要加锁，更轻量级，也不会阻塞线程

# JAVA中的锁有哪些处理方式？

## 悲观锁和乐观锁的区别什么？
`乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度`。
悲观锁认为自己在使用数据的时候一定有别的线程来修改数据(被害妄想症？)，<br>
因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。<br>
Java中，`synchronized关键字和Lock的实现类都是悲观锁`。


而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，<br>
只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。<br>
如果这个数据没有被更新，当前线程将自己修改的数据成功写入。<br>
如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。


乐观锁在Java中是通过使用无锁编程来实现，最常采用的是 **`CAS`** 算法，Java原子类中的递增操作就通过CAS自旋实现的。

### 总结
悲观锁适合`写操作多的场景`，先加锁可以保证写操作时数据正确。<br>
乐观锁适合`读操作多的场景`，不加锁的特点能够使其读操作的性能大幅提升。

# CAS 自旋是怎么回事？
阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。<br>
如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。

因此如果A线程中的同步代码块就简单的几行逻辑代码，那么当B线程去获取A线程的锁的时候，我们将B线程进行自旋，<br>
如果在自旋完成后A线程锁定同步资源的线程已经释放了锁，<br> 
那么B线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。


# 自旋有什么缺点？
**`自旋等待虽然避免了线程切换的开销，但它要占用处理器时间`**。

如果锁被占用的时间很短，自旋等待的效果就会非常好。<br> 
反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。<br> 
所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（`默认是10次`，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。

自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。
所谓适应性自旋锁就是内部逻辑判断这个锁是否需要自旋，自旋次数应该是多少。

# 能说说对synchronized的理解吗？
